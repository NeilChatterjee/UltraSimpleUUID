#include "../UltraSimpleUUID.h"
/*
Neil Chatterjee 2020

This test generates 4096 UUIDs and then generates UUIDs until it finds collisions for all of them. 

This test exists as a sanity-check only, if you want to confirm that the UUIDs being generated by
this algorithm are sufficiently random for your purposes. It takes quite long to run, in the case 
of my laptop (intel core i7 8650U) it took 61 hours to find collisions for all UUIDs. Calculating 
specific chances of something happening experimentally is extremely difficult. This is more to varify
that the randomness is very high. Since "random" numbers generated by computers are only pseudorandom
it's fair to assume that the actual ranomness of UUIDs is less than the theoretical 1:2.2x10^57

In my trial run, the average UUID collidied after aproximatley 10 million tries, and the slowest of them
matched after aproximatley 41 billion tries. This fits with the assertion that the UUIDs are "very very
very unlikely to collide"
*/

#include <iostream>
#include <unordered_set>
#include <cassert>
#include <chrono>
#include <algorithm>


int main(int argc, char* argv[])
{
	std::unordered_set<std::string> uuids;
	for (int i = 0; i < 4096; i++)
	{
		uuids.insert(UltraSimpleUUID::generate());
	}
	int initial_uuid_count = uuids.size();
	
	std::chrono::time_point<std::chrono::system_clock> sec_countdown_time = std::chrono::system_clock::now();
	std::chrono::time_point<std::chrono::system_clock> start_time = std::chrono::system_clock::now();
	int num_tries = 0;
	int seconds_recorded = 0;
	int avg_tries_per_second = -1;

	std::vector<unsigned long long> elapsed;


	// start a timer (or a counter) here
	UltraSimpleUUID::Uuid uuid;
	uuid.randomize();
	while (uuids.size() > 0)
	{
		if (uuids.count(uuid.toString()) > 0)
		{
			unsigned long long seconds_elapsed = std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now() - start_time).count();
			uuids.erase(uuid.toString());
			std::cout << "Match found after " << seconds_elapsed << " seconds at a rate of " << avg_tries_per_second << " attempts per seond. " << uuids.size() << " UUIDs remaining" << std::endl;
			float percentage_found = (float)(initial_uuid_count - uuids.size()) / (float)initial_uuid_count; percentage_found *= 100.0f;
			elapsed.push_back(seconds_elapsed);

			double avg_interval = 0;
			for (int i = 0; i < elapsed.size()-1; i++)
			{
				avg_interval += (double)(elapsed[i+1] - elapsed[i]) / (double)elapsed.size();
			}
			std::cout << percentage_found << "% of UUIDs matched a rate of one per " << avg_interval << " seconds." << std::endl;
			// we're assuming a constant rate
			//unsigned long long projected_avg = (unsigned long long)avg_interval * (initial_uuid_count / 2);
			double projected_avg = avg_interval * (double)(initial_uuid_count / 2);
			std::cout << "At this rate, projected average search time will be " << projected_avg << " seconds." << std::endl;
			std::cout << "(Note, the longer this runs the more accurate it will become because of randomness.)" << std::endl;


			std::cout << std::endl;

		}
		if (std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now() - sec_countdown_time).count() >= 1)
		{
			sec_countdown_time = std::chrono::system_clock::now();
			avg_tries_per_second = avg_tries_per_second * seconds_recorded + num_tries;
			seconds_recorded++;
			avg_tries_per_second /= seconds_recorded;
			seconds_recorded = std::min(seconds_recorded, 256);
			num_tries = 0;
		}

		num_tries++;
		uuid.randomize();
	}

	// end a timer here
	std::cout << "Finished" << std::endl;
	unsigned long long avg_seconds = 0;
	for (int i = 0; i < elapsed.size(); i++)
	{
		avg_seconds += (elapsed[i] / elapsed.size());
	}
	std::cout << "Average time:			 " << avg_seconds << std::endl;
	std::cout << "Average tries/second : " << avg_tries_per_second << std::endl;
} 